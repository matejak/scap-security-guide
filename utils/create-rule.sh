#!/bin/bash

# Created by argbash-init v2.9.0
# ARG_OPTIONAL_SINGLE([varname])
# ARG_OPTIONAL_SINGLE([template],[t])
# ARG_POSITIONAL_SINGLE([name],[ID of the rule])
# ARG_POSITIONAL_SINGLE([path],[(Relative or absolute) path where to create the rule, e.g. linux_os/guide/system],[.])
# ARG_DEFAULTS_POS([])
# ARG_HELP([Create a rule structure in a given location])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='th'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_name=
_arg_path="."
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_varname=
_arg_template=


print_help()
{
	printf '%s\n' "Create a rule structure in a given location"
	printf 'Usage: %s [--varname <arg>] [-t|--template <arg>] [-h|--help] <name> [<path>]\n' "$0"
	printf '\t%s\n' "<name>: ID of the rule"
	printf '\t%s\n' "<path>: (Relative or absolute) path where to create the rule, e.g. linux_os/guide/system (default: '.')"
	printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			--varname)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_varname="$2"
				shift
				;;
			--varname=*)
				_arg_varname="${_key##--varname=}"
				;;
			-t|--template)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_template="$2"
				shift
				;;
			--template=*)
				_arg_template="${_key##--template=}"
				;;
			-t*)
				_arg_template="${_key##-t}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'name'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 1 and 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 1 and 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_name _arg_path "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

TEMPLATE_TEMPLATE=""
test -z "$_arg_template" || TEMPLATE_TEMPLATE="

template:
    name: $_arg_template
    vars:
        # Refer to the guide at
	# https://github.com/ComplianceAsCode/content/blob/master/docs/manual/developer_guide.adoc#templating
	# to learn about possible parameters of your template
	# parameter: value
"

XCCDF_USE_VAR=""
test -z "$_arg_varname" || XCCDF_USE_VAR="
    # As you have declared an intent to use a variable, mention it in the description, e.g.
    This rule is parametrized by <code>$_arg_varname</code>, with has value of {{{ sub_var_value(\"$_arg_varname\") }}} in this setting.
"

RULE_TEMPLATE="documentation_complete: true

# Set prodtypes if needed, otherwise let the rule to be applicable for all products by omitting the prodtype declaration
# prodtype: fedora

title: '<YOUR TITLE HERE>'

description: |-
    <YOUR DESCRIPTION
    HERE>$XCCDF_USE_VAR
    # Typically, you put something between general context overview, and what exactly needs to be set up.

rationale: |-
    <YOUR RATIONALE
    HERE>
    # Go into a greater detail of why is this rule important at all.

severity: medium

identifiers:
    # You may want to add a CCE in form of cce@<product>: CCE-... s.a.
    # cce@rhel7: CCE-82156-1
    # If you are acting on behalf of Red Hat, take a random CCE from shared/references/cce-redhat-avail.txt, delete it from there, and add it here.

references:
    # Reference to the policy/security control. May or may not be product-qualified, e.g.
    # cis@rhel8: 4.1.1.4

# The second part of the sentence explaining what got wrong.
# ... Is it the case that <YOUR ocil_clause>
ocil_clause: '<YOUR OCIL CLAUSE HERE>'

# A setp-by-step guide how to modify the configuration to achieve compliance
ocil: |-
    <YOUR GUIDE
    HERE>

# If you would like to warn about possible side-effects of this rule, specify some warnings.
# Warnings is a list of dicts, where keys are given by the XCCDF standard, can be 'general', 'performance', 'legal' etc.
# warnings:
#    - general: |-
#        <YOUR WARNING
#        HERE>

# Applicability limitation, you likely don't need it
# Specify 'machine' if this rule doesn't make sense on containers,
# or use other defined platforms to skip the OVAL check
# platform: machine$TEMPLATE_TEMPLATE
"


OVAL_USE_VAR=""
test -z "$_arg_varname" || OVAL_USE_VAR="

</definition><external_variable comment=\"external variable ...\" datatype=\"YOUR VAR DATATYPE HERE\" id=\"$_arg_varname\" version=\"1\" />"

OVAL_TEMPLATE="
<def-group>
   <definition class=\"compliance\" id=\"$_arg_name\" version=\"1\">
     {{{ oval_metadata(\"YOUR SHORT DESCRIPTION HERE\") }}}
     <criteria operator=\"AND\">
        <criterion comment=\"YOUR COMMENT HERE\" test_ref=\"YOUR TEST ID HERE\" />
     </criteria>
  </definition>

  <!-- YOUR TESTS, OBJECTS AND STATES HERE-->$OVAL_USE_VAR
</def-group>
"


BASH_USE_VAR=""
test -z "$_arg_varname" || BASH_USE_VAR="

{{{ bash_instantiate_variables('$_arg_varname') }}}"

BASH_TEMPLATE="
# platforms: multi_platform_all$BASH_USE_VAR
"


TEST_PASS_TEMPLATE="# platform = multi_platform_all

# Use bash to create a test scenario that should make the check to pass
"


TEST_FAIL_TEMPLATE="# platform = multi_platform_all

# Use bash to create a test scenario that the check evaluates as incompliant.
# If remediation can't fix this, specify  # remediation = none under the platform header
"

set -e
RULE_DIR="${_arg_path}/${_arg_name}"
mkdir -p "$RULE_DIR"
test -f "$RULE_DIR/rule.yml" || printf "%s" "$RULE_TEMPLATE" > "$RULE_DIR/rule.yml"

mkdir -p "$RULE_DIR/oval"
test -f "$RULE_DIR/oval/shared.xml" || printf "%s" "$OVAL_TEMPLATE" > "$RULE_DIR/oval/shared.xml"

mkdir -p "$RULE_DIR/bash"
test -f "$RULE_DIR/bash/shared.sh" || printf "%s" "$BASH_TEMPLATE" > "$RULE_DIR/bash/shared.sh"

mkdir -p "$RULE_DIR/tests"
test -f "$RULE_DIR/tests/simple.pass.sh" || printf "%s" "$TEST_PASS_TEMPLATE" > "$RULE_DIR/tests/simple.pass.sh"
test -f "$RULE_DIR/tests/simple.fail.sh" || printf "%s" "$TEST_FAIL_TEMPLATE" > "$RULE_DIR/tests/simple.fail.sh"

# ] <-- needed because of Argbash
